# Algorithms
All are implemented using C++/C programming language
1. Divide and Conquer

   1.1. Merge Sort: 
      A type of sorting technique with time complexity of O(nlogn). Requires an auxillary array 
      
    1.2. Quick Sort:
      A type of sorting technique with time complexity of O(nlogn) (using Randomized algorithm). No extra space required. 
      
    1.3. Binary Search:
      A type of searching algorithm. Time complexity of O(logn) (Average-case)
      
    1.4. Number of inversions in an array: 
      Inversion Count for an array indicates â€“ how far (or close) the array is from being sorted. If array is already sorted then             inversion count is 0. If array is sorted in reverse order that inversion count is the maximum. Formally speaking, two elements           a[i] and a[j] form an inversion if a[i] > a[j] and i < j
      
    1.5. Karatsuba Multiplication: 
      The Karatsuba algorithm is a fast multiplication algorithm. It was discovered by Anatoly Karatsuba in 1960 and published in 1962.       It reduces the multiplication of two n-digit numbers to at most single-digit multiplications in general (and exactly when n is a         power of 2)
      
    1.6. Closest Pair Problem:
      The closest pair of points problem or closest pair problem is a problem of computational geometry: given n points in metric space,       find a pair of points with the smallest distance between them.
      
2. Graph Algorithms

    2.1. Breadth First Search:
      Breadth-first search is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root, and         explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.
      
         2.1.1. Shortest Path: Given a unweighted graph, a source and a destination, finds shortest path from source to destination in the graph in most optimal way.
         2.1.2 Connected Components: for undirected graphs
         2.1.3 Two Coloring Graph: Check if the graph is bipartite i.e. if the vertices of the graph can be divided into two independent sets A and B.  
         
     2.2.  Depth First Search: 
          
          2.2.1 Shortest Connected Components 
   
4. Greedy Algorithms
   
   4.1. Prim's Algorithm
5. Dynamic Programming
